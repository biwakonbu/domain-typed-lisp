# v0.3 停止性解析設計

## 1. 背景
- v0.2 は関数再帰（自己再帰・相互再帰）を `E-TOTAL` で一律禁止している。
- 現状は停止性を「言語制約で保証」しているため、実用上必要な再帰関数（リスト処理など）を表現できない。

## 2. 設計目標
- 停止しない可能性を持つ関数を静的に拒否する。
- 停止が明白な再帰（構造再帰）を段階的に許可する。
- `check` 時点で判定可能な規則に限定し、`prove` の探索コストを悪化させない。

## 3. 非目標（v0.3）
- 任意の一般再帰を受理すること。
- SMT ベースの完全な停止性証明。
- 停止性判定のための実行時監視。

## 4. 段階移行計画

### Phase 0（v0.2 現状）
- すべての再帰を禁止。
- 実装: `typecheck` で call graph を作り、SCC が自己ループまたは多ノードなら `E-TOTAL`。

### Phase 1（v0.3 目標）
- 単一関数の自己再帰のみ許可。
- 許可条件:
  - 再帰呼び出しが関数本体の末尾位置（tail position）にある。
  - 少なくとも 1 引数が「構造的に縮小」している。
  - 縮小対象は ADT 値のみ（`match` 分解で得た部分値を再帰引数に渡す）。
- それ以外は `E-TOTAL` で拒否。

### Phase 2（v0.4 候補）
- 相互再帰を SCC 単位で許可。
- size-change termination の簡易版（呼び出し辺ごとの減少行列）を導入。
- 複数引数の辞書式減少を許可。

## 5. 判定アルゴリズム（Phase 1）
1. `defn` ごとに本体 AST から再帰呼び出し箇所を抽出する。
2. 各呼び出しが tail position かを構文的に判定する。
3. 各呼び出し引数について、以下のいずれかを満たすか判定する。
   - 元引数を `match` で分解して得た constructor の部分項（strict subterm）
   - 減少保証のある補助関数（v0.3 では未導入）
4. 1 呼び出しでも条件を満たさない場合は `E-TOTAL`。

## 6. 診断設計
- `E-TOTAL`: recursive function is not structurally decreasing
- 付帯情報:
  - 問題の再帰呼び出し span
  - 減少が確認できなかった引数 index
  - 想定修正（`match` で分解し部分値を渡す）

## 7. 既存モジュールへの影響
- `src/typecheck.rs`
  - 現在の「再帰一律禁止」を「停止性判定」に置換。
  - AST 走査ユーティリティを追加（tail position / strict subterm）。
- `src/parser.rs`
  - v0.3 では文法追加なし（`decreases` 注釈は導入しない）。
- `src/prover.rs`
  - 直接の変更なし（停止性は `check` フェーズで保証）。

## 8. リスクと緩和
- リスク: tail 判定や subterm 判定のバグで誤受理。
  - 緩和: 負例テスト（`if`/`let`/`match` ネスト）を先に追加し、受理条件を保守的にする。
- リスク: 正当な関数を拒否し過ぎる。
  - 緩和: v0.3 は保守的運用とし、v0.4 で判定強化。

## 9. 受け入れ基準（v0.3）
- 構造再帰の代表例（長さ計算・全要素判定）が `check` 通過。
- 明らかな非停止例（同一引数で自己再帰、増大再帰、非 tail 再帰）が `E-TOTAL`。
- 既存 v0.2 テストに回帰がない。
